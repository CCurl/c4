( block 2 - editor )

  3 load ( strings )
  4 load ( alloc/free )
  5 load ( screen )
111 load ( keys )

( idea: )
( have 2 buffers, for 2 copies of the file, current and working )
( have a temp buffer for the current line )
( keep an array of addresses of where each line starts )
( keep that updated as things change )
( also sync the buffers up constantly as things change )

2 >lex  decimal

: re forget 2 load ;

: lines      40 @c ;  : >lines      40 !c ;
: scr-top    41 @c ;  : >scr-top    41 !c ;
: rows       42 @c ;  : >rows       42 !c ;  : max-row rows 1- ;
: row        43 @c ;  : >row        43 !c ;
: col        44 @c ;  : >col        44 !c ;
: blk        45 @c ;  : >blk        45 !c ;
: dirty?     46 @c ;  : dirty     1 46 !c ;  : clean   0 46 !c ;
: block-sz   47 @c ;  : >block-sz   47 !c ;
: cols       48 @c ;  : >cols       48 !c ;  : max-col cols 1- ;
: ed-mode    49 @c ;  : >ed-mode    49 !c ;
: normal-mode 0 ;     : quit-mode 99 ;
: insert-mode  1 ;    : replace-mode  2 ;
: normal-mode?  ed-mode normal-mode = ;
: insert-mode?  ed-mode insert-mode = ;
: replace-mode? ed-mode replace-mode = ;
: .mode space normal-mode? if ." -normal-" exit then
    insert-mode?  if z" -insert-" then
    replace-mode? if z" -replace-" then
    red ztype white ;
: insert-toggle insert-mode? if normal-mode else insert-mode then >ed-mode ;

6000 >block-sz
 200 >lines      100 >cols
   0 >scr-top     25 >rows

block-sz 2+ var block
block-sz 2+ var work
lines cells var (lines)
cols 2+     var cur-line

 8  const ed-left
12  const ed-right
11  const ed-up
10  const ed-down
 4  const ed-pgdn
21  const ed-pgup

: norm ( n1 l h--n2 ) >r max r> min ;
: valid-line? ( n--f ) 0 lines btwi ;
: line-addr  ( row--a )  dup valid-line? 0= if drop 0 exit then cell * (lines) + @ ;
: >line-addr ( a row-- ) dup valid-line? 0= if 2drop  exit then cell * (lines) + ! ;
: real-row ( --n ) row scr-top + ;
: rc->pos  ( --n ) real-row line-addr -if col + then ;
: ->cur   row 1+ col 1+ ->rc ;
: ->foot  rows 1+ 1 ->rc ;
: ->cmd   rows 2+ 1 ->rc ;
: get-tmp-line ( -- ) real-row line-addr ?dup
    if cur-line swap s-cpy drop else 0 cur-line c! then ;
: apply-tmp-line ( prev-line-- ) drop ;
: mv-col ( n-- ) col + 0 max-col norm >col ;
: mv-row ( n-- ) 
    x> >t real-row >x
    row + 0 max-row norm >row
    real-row x> <> if
        x> apply-tmp-line
        get-tmp-line
    then t> >x ;
: mv ( r c-- ) mv-col mv-row ;
: lpar. '(' emit (.) ; : .rpar (.) ')' emit ;
: footer ->foot ."  - Block " blk . 
    dirty? if '*' else bl then emit
    space real-row 1+ lpar. ',' emit col 1+ .rpar .mode clr-eol ;
: show ( -- )  1 dup ->rc 
    rows for 
        i scr-top + line-addr ?dup if ztype then 
        clr-eol cr
    next footer ;
: scroll scr-top + 0 lines rows - norm >scr-top show ;
: init-lines  (lines) 0 lines fill-c ;
: init-block  block 0 block-sz fill ;
: hex-dump base@ >r hex 1 +regs
    for dup c@ .02 space 1+ a+ $20 > if cr 1 >a then next drop
    drop -regs r> base !c ;
: dump-block  block block-sz hex-dump ;
: fopen-rb ( fn--fh )  z" rb" fopen ;
: fopen-wb ( fn--fh )  z" wb" fopen ;
: block-fn ( --fn ) p1 s" block-" s-cpy
    blk 10 /mod 10 /mod
    3 for p1 swap '0' + s-catc drop next
    s" .c4" s-cat 1+ ;

: prep-block ( -- ) init-lines
    +regs block >s  100  alloc .s >d  0 >x  d> x+ >line-addr
    begin
        s> c@ ?dup 0= if -regs exit then
        dup 10 =
        if drop 0 d> c!  100 alloc >d  d> x>+ >line-addr
        else 32 max d>+ c!
        then
    again ;

: load-block ( -- ) init-block
    block-fn fopen-rb ?dup if
      >t block block-sz t@ fread drop t> fclose 
    then prep-block ;

: save-block block-fn fopen-wb ?dup if
      >r block block-sz r@ fwrite drop r> fclose
    then ;

: block->work  block work block-sz cmove ;
: work->block  block->work +regs work >s block >d
    lines for
        i line-addr dup >s 0= if -regs unloop exit then
        begin
            s>+ c@ dup if d>+ c! then
        while
    next ;
    -regs ;

: >cur-line cur-line s-trunc line-addr ?dup if s-cpy drop then ;

: replace-char ( -- ) rc->pos ?dup if a> swap c! 0 1 mv dirty then ;
: insert-blank ( -- ) ;
: insert-char  ( -- ) insert-blank replace-char ;
: insert-line  ( -- ) ;
: delete-char  ( -- ) ;
: delete-line  ( -- ) ;

: do-cmd ->cmd ':' emit
    p1 accept
    p1 s" q"  s-eq if  quit-mode >ed-mode exit  then
    p1 s" q!" s-eq if  quit-mode >ed-mode exit  then
    p1 s" wq" s-eq if  quit-mode >ed-mode exit  then
    p1 s" w"  s-eq if  clean exit  then ;

: quit? ed-mode quit-mode = ;
: do-ctrl ( -- )
    a> key-up    = if -1  0 mv   exit then
    a> key-down  = if  1  0 mv   exit then
    a> key-left  = if  0 -1 mv   exit then
    a> key-right = if  0  1 mv   exit then
    a> key-pgdn  = if  10 scroll exit then
    a> key-pgup  = if -10 scroll exit then
    a> ed-up     = if -1  0 mv   exit then
    a> ed-down   = if  1  0 mv   exit then
    a> ed-left   = if  0 -1 mv   exit then
    a> ed-right  = if  0  1 mv   exit then
    a> ed-pgdn   = if  10 scroll exit then
    a> ed-pgup   = if -10 scroll exit then
    a> key-ins   = if insert-toggle exit then
    a> key-home  = if 0 >col exit then
    a>  3 = if  0 >ed-mode exit then ( stop )
    a>  9 = if  0  8 mv exit then ( tab-right )
    a> 17 = if  0 -8 mv exit then ( tab-left )
    a>  5 = if   1 scroll exit then ( scrdn )
    a> 25 = if  -1 scroll exit then ( scrup )
    ;
: do-work ( c-- )
    a> bl < if do-ctrl exit then
    a> $100 > if do-ctrl exit then
    insert-mode?  = if insert-char  exit then
    replace-mode? = if replace-char exit then
    a> ':' = if  do-cmd exit then
    a> 'h' = if  0 -1 mv exit then ( left )
    a> 'l' = if  0  1 mv exit then ( right )
    a> 'k' = if -1  0 mv exit then ( up )
    a> 'j' = if  1  0 mv exit then ( down )
    a> 'q' = if  0  8 mv exit then ( tab-right )
    a> 'Q' = if  0 -8 mv exit then ( tab-left )
    a> '_' = if  0 >col  exit then ( home )
    a> '$' = if  cols 1- >col exit then ( end )
    a> 'i' = if insert-mode >ed-mode  exit then
    a> 'r' = if replace-mode key >a replace-char exit then
    a> 'R' = if replace-mode >ed-mode exit then
    ;
: ed-loop begin quit? if exit then show ->cur vkey >a do-work again ;
: ed-init 0 >ed-mode 0 >row 0 >col 0 >scr-top ;
: edit ( blk-- ) >blk load-block ed-init cls ed-loop ->cmd ;
: ed 70 >rows edit ;
