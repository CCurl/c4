: ->code code + ;
: ->vars vars + ;
: ->dict dict + ;
: @c dup + ->code w@ ;
: !c dup + ->code w! ;
: here  (here)  @c ;
: last  (last)  @c ;
: vhere (vhere) @c ;
: lex   (lex)   @c ;
: >lex  (lex)   !c ;
: , here  dup 1+     (here)  !c !c ;
: begin here ; immediate
: again (jmp)   , , ; immediate
: while (jmpnz) , , ; immediate
: until (jmpz)  , , ; immediate
: if (jmpz) , here 0 , ; immediate
: else (jmp) , here swap 0 , here swap !c ; immediate
: then here swap !c ; immediate
: ( begin
    >in @ c@ 
    dup  0= if drop exit then
    >in @ 1+ >in !
    ')' = if exit then
  again ; immediate
: allot vhere + (vhere) !c ;
: ,v  vhere ->vars ! cell allot ;
: hex     $10 base !c ;
: binary  %10 base !c ;
: decimal #10 base !c ;
: cells cell * ;
: nip swap drop ;
: tuck swap over ;
: ?dup dup if dup then ;
: negate com 1+ ;
: abs dup 0 < if negate then ;
: mod /mod drop ;
: +! tuck @ + swap ! ;
: space 32 emit ;
: . (.) space ;
: cr 13 emit 10 emit ;
: tab 9 emit ;
: ?  @ . ;
: a+c a dup cell + >a ;
: !a   a ! ;   : !a+   a+c ! ;
: @a   a @ ;   : @a+   a+c @ ;
: c!a  a c! ;  : c!a+  a+  c! ;
: c@a  a c@ ;  : c@a+  a+  c@ ;
: ->xt     w@ ;
: ->size   2 + c@ ;
: ->flags  3 + c@ ;
: ->lex    4 + c@ ;
: ->len    5 + ;
: ->name   6 + ;
: lex-match? ( a--f )  ->lex lex =  lex 0=  or ;
: words a >r  0 dup >a >r  last ->dict begin
      dup lex-match? if
        dup ->len count type  r> 1+ >r
        a+ 8 > if cr 0 >a else tab then
      then
      dup ->size + dup dict-sz ->dict <
    while drop '(' emit r> . ." words)" r> >a ;
: does> (jmp) , r> , ;
: create addword ; immediate
: var   addword cell allot (exit) , ; immediate
: const addword ,v does> @ ; immediate
var hh
var ll
var vv
: marker here hh ! last ll ! vhere vv ! ;
: forget hh @ (here) !c ll @ (last) !c vv @ (vhere) !c 0 >lex ;
marker
." c4 - v24.06.01 - chris curl." cr
